<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0082)https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c2 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="./The Web Application Hacker&#39;s Handbook - Answers_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app42.us.archive.org';v.server_ms=247;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/ait-client-rewrite.js" charset="utf-8"></script>
<script type="text/javascript">
WB_wombat_Init("https://web.archive.org/web", "20151027041737", "mdsec.net:80");
</script>
<script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/wbhack.js" charset="utf-8"></script>
<script type="text/javascript">
__wbhack.init('https://web.archive.org/web');
</script>
<link rel="stylesheet" type="text/css" href="./The Web Application Hacker&#39;s Handbook - Answers_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./The Web Application Hacker&#39;s Handbook - Answers_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

<meta content="en-gb" http-equiv="Content-Language">

<meta content="IE=Edge" http-equiv="X-UA-Compatible">
<title>The Web Application Hacker's Handbook - Answers</title>
<link href="./The Web Application Hacker&#39;s Handbook - Answers_files/ps.css" rel="stylesheet" type="text/css">
<link href="./The Web Application Hacker&#39;s Handbook - Answers_files/wahh.css" rel="stylesheet" type="text/css">
<!--[if IE 6]>
<link href="../css/ie6.css" rel="stylesheet" type="text/css" />
<![endif]--><!--[if IE 7]>
<link href="../css/ie7.css" rel="stylesheet" type="text/css" />
<![endif]-->
<link href="https://web.archive.org/web/20151027041737im_/http://mdsec.net/css/favicon.png" rel="icon" type="image/png">
<!--[if IE]>
<link href="../css/favicon.ico" rel="shortcut icon" />
<![endif]-->
</head>

<body><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/timestamp.js" charset="utf-8"></script>
<script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/graph-calc.js" charset="utf-8"></script>
<script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/auto-complete.js" charset="utf-8"></script>
<script type="text/javascript" src="./The Web Application Hacker&#39;s Handbook - Answers_files/toolbar.js" charset="utf-8"></script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
.wb-autocomplete-suggestions {
    text-align: left; cursor: default; border: 1px solid #ccc; border-top: 0; background: #fff; box-shadow: -1px 1px 3px rgba(0,0,0,.1);
    position: absolute; display: none; z-index: 2147483647; max-height: 254px; overflow: hidden; overflow-y: auto; box-sizing: border-box;
}
.wb-autocomplete-suggestion { position: relative; padding: 0 .6em; line-height: 23px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 1.02em; color: #333; }
.wb-autocomplete-suggestion b { font-weight: bold; }
.wb-autocomplete-suggestion.selected { background: #f0f0f0; }
</style>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><script type="text/javascript">
__wm.bt(600,27,25,2,"web","http://mdsec.net/wahh/answers2e.html","2015-10-27",1996,"/_static/",['css/banner-styles.css','css/iconochive.css']);
</script><div class="wb-autocomplete-suggestions " style="left: 163px; top: 36px; width: 682px;"></div>
<!-- END WAYBACK TOOLBAR INSERT -->

<div id="TopBanner">
<ul>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/">MDSec home</a></li>
</ul>
</div>
<div id="NavBar">
<ul>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/">WAHH</a></li>
<li>&gt;<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html">Answers</a> (Second Edition)</li>
</ul>
</div>

<div id="MainContent">
<div class="RightHandBox">
<div class="GreyBox">
<div class="TopCorners"></div>
<p>Site Contents</p>
<ul>
<li>Second edition:<ul>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/toc2e.html">Book contents</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html">Answers</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/code2e.html">Source code</a></li>
</ul></li>
<li>First edition:<ul>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/toc1e.html">Book contents</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers1e.html">Answers</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/code1e.html">Source code</a></li>
</ul></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/tools.html">Tools</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/tasks.html">Task checklist</a></li>
<li><a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/buy.html">Buy</a></li>
</ul>
<div class="BottomCorners"></div>
</div>
</div>
<p>This page contains the answers to the questions posed at the end of each 
chapter of the second edition.</p>
<p>Jump to chapter:&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c2">2</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c3">3</a>&nbsp;
<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c4">4</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c5">5</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c6">6</a>&nbsp;

<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c7">7</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c8">8</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c9">9</a>&nbsp;
<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c10">10</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c11">11</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c12">12</a>&nbsp;
<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c13">13</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c14">14</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c15">15</a>&nbsp;

<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c16">16</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c17">17</a>&nbsp; <a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c18">18</a>&nbsp; 
<a href="https://web.archive.org/web/20151027041737/http://mdsec.net/wahh/answers2e.html#c19">19</a></p>
<a name="c2"></a>
<h2>Chapter 2 – Core Defense Mechanisms</h2>
<ol>
<li>In a typical application, access is handled using a trio of mechanisms 
relating to authentication, session management, and access control. These 
components are highly interdependent, and a weakness in any one of them 
will undermine the effectiveness of the overall access handling mechanism. 
For example, a defective authentication mechanism may enable an attacker 
to login as any user and so gain unauthorized access. If session tokens 
can be predicted, an attacker may be able to masquerade as any logged in 
user and gain access to their data. If access controls are broken, then 
any user may be able to directly use functionality that is supposed to be 
protected. </li>

<li>
<p>A session is a set of data structures held on the server, which are used 
to track the state of the user’s interaction with the application. A session 
token is a unique string that the application maps to the session, and is 
submitted by the user to reidentify themselves across successive requests.
</p>
</li>
<li>There are many situations where an application may be forced to accept 
data for processing that does not match a list or pattern of input that 
is known to be “good”. For example, many people’s names contain characters 
that can be used in various attacks. If an application wishes to allow people 
to register under their real names, it needs to accept input that may be 
malicious, and ensure that this is handled and processed in a safe manner 
nevertheless. </li>
<li>
<p>Defects in the any of the core mechanisms for handling access may enable 
you to gain unauthorized access to the administrative functionality. Further, 
data that you submit as a low privileged user may ultimately be displayed 
to administrative users, enabling you to attack them by submitting malicious 
data designed to compromise their session when it is viewed. </p>
</li>

<li>
<p>Yes. If it were not for Step 4, this mechanism would be robust in terms 
of filtering the specific items it is designed to block. However, because 
your input is decoded <i>after</i> the filtering steps have been performed, 
you can simply URL-encode selected characters in your payload to evade the 
filter:</p>
<p><span class="InlineCode">%22&gt;%3cscript&gt;alert(%22foo%22)&lt;/script&gt;</span></p>
<p>If Step 4 were performed first (or even not at all) then this bypass 
would not be possible. </p>

</li>
</ol>
<a name="c3"></a>
<h2>Chapter 3 – Web Application Technologies</h2>
<ol>
<li>The <span class="InlineCode">OPTIONS</span> method asks the server to 
report the HTTP methods that are available for a particular resource.
</li>

<li>
<p>The <span class="InlineCode">If-Modified-Since</span> header is used 
to specify the time at which the browser last received the requested resource. 
The <span class="InlineCode">If-None-Match</span> header is used to specify 
the entity tag that the server issued with the requested resource when it 
was last received.</p>
<p>In the two ways described, these headers are used to support caching 
of content within the browser, and they enable the server to instruct the 
browser to use a cached copy of a resource, rather than responding with 
the full contents of the resource if this is not necessary.</p>
<p>When you are attacking an application, your browser may already have 
cached copies of resources that you are interested in, such as JavaScript 
files. By removing these two headers, you can override the browser’s caching 
information and ensure that the server responds with a fresh copy of the 
resource you wish to view. </p>

</li>
<li>The <span class="InlineCode">secure</span> flag is used to instruct 
the browser that the cookie should only ever be resubmitted over HTTPS connections, 
and never unencrypted HTTP. </li>
<li>
<p>The 301 status code tells the browser that the requested resource has 
moved permanently to a different location. For duration of the current browser 
session, if your browser needs to access the originally requested resource, 
it will use the location specified in the 301 response instead.</p>
<p>The 302 status code tells the browser that the requested resource has 
moved temporarily to a different location. On the next occasion that the 
browser needs to access the originally requested resource, it will request 
this from the originally requested location. </p>
</li>

<li>The browser sends a <span class="InlineCode">CONNECT</span> request 
to the proxy, specifying the destination hostname and port number as the 
URL within this request. If the proxy allows the request, it returns an 
HTTP response with a 200 status, keeps the TCP connection open, and from 
that point onwards acts as a pure TCP-level relay to the specified destination.
</li>
</ol>
<a name="c4"></a>
<h2>Chapter 4 – Mapping the Application</h2>
<ol>

<li>
<p>The filename <span class="InlineCode">CookieAuth.dll</span> indicates 
that Microsoft ISA server is being used. This is the URL for the login function, 
and after a successful login the application will redirect to the URL
<span class="InlineCode">/default.aspx</span>. </p>
</li>
<li>
<p>The URL is a common fingerprint for the phpBB web forum software. Information 
about this software is readily available on the Internet, and you can perform 
your own installation to experiment on. A listing of members can be found 
at the following URL:</p>

<p><span class="InlineCode">http://wahh-app.com/forums/memberlist.php</span></p>
<p>Individual user profiles can be found via URLs like the following:</p>
<p><span class="InlineCode">http://wahh-app.com/forums/profile.php?mode=viewprofile&amp;u=2</span></p>
<p>Various vulnerabilities have been found in the phpBB software so you 
should confirm the version in use and research any associated problems.
</p>
</li>
<li>The <span class="InlineCode">.asp</span> file extension indicates that 
Microsoft’s Active Server Pages are in use. The use of a
<span class="InlineCode">/public</span> path indicates that other interesting 
paths might exist, such as <span class="InlineCode">/private</span>. The
<span class="InlineCode">action=view</span> parameter suggests that other 
actions may exist, such as <span class="InlineCode">edit</span>,
<span class="InlineCode">add</span> or <span class="InlineCode">delete</span>. 
The function of the <span class="InlineCode">location=default</span> parameter 
should be investigated – this may contain a filename, and you should probe 
the application for path traversal vulnerabilities. </li>

<li>If the header is accurate, it indicates that the server is running Apache 
Tomcat. Tomcat is a Java Servlet Container, so the application probably 
uses Java and JSP technologies. </li>
<li>
<p>The first response uses the HTTP status code 200, which normally indicates 
that the request was successful. However, the Content-Location header indicates 
the location from which the response was retrieved. This appears to be a 
dynamically generated error page, and includes the value 404 in its query 
string, indicating that the response contains a customized “file not found” 
message.</p>
<p>The second response uses the HTTP status code 401, which suggests that 
the requested resource is present but that users must supply HTTP authentication 
credentials in order to access it.</p>
<p>In each case, you could substantiate your conclusion by requesting a 
clearly non-existent item in the same directory with the same extension 
(for example, <span class="InlineCode">/iuwehuiwefuwedw.cpf</span>) and 
comparing the responses. In the first application, you would expect to see 
a response very similar to the original. In the second application, you 
would expect to see a different response containing a “file not found” message.
</p>
</li>

</ol>
<a name="c5"></a>
<h2>Chapter 5 – Bypassing Client-Side Controls</h2>
<ol>
<li>The data can be encrypted or hashed using a key stored on the server, 
as is optionally done for the ASP.NET ViewState. Unless an attacker somehow 
captures the key, they will be unable to encrypt arbitrary data or compute 
a valid hash for arbitrary data. However, the attacker may still be able 
to take data from one context and replay it in another – for example, the 
encrypted price for a cheap item could be submitted in place of the encrypted 
price for an expensive item. To prevent this attack, the application should 
include sufficient context within the protected data to be able to confirm 
that it originated in the same context as it is being employed – for example, 
the product code and price could be combined in a single encrypted blob.
</li>
<li>
<p>The defense is trivial to bypass. An attacker does not need to submit 
the cookie that tracks the number of failed login attempts. They can either 
disable cookies in their browser, or use an automated script that submits 
requests without the relevant cookie.</p>

<p>An alternative defense would be to use CAPTCHA controls to slow down 
an attacker, or to block the source IP address after five failed logins, 
although this may have an adverse impact where multiple clients are located 
behind a proxy or a NAT-ting firewall. </p>
</li>
<li>
<p>(a) The Referer header can be set to an arbitrary value by 
an attacker, and so is not a safe means of performing any access control 
checks.</p>
<p>(b) This method will only be effective if the web server 
containing the diagnostic functions is in a parent or child domain of the 
originating web server, and the session cookie is appropriately scoped, 
otherwise the cookie will not be submitted to the diagnostic server. A back-end 
mechanism will need to be implemented for the diagnostic server to validate 
the submitted tokens with the originating server.</p>
<p>(c) This method will be effective regardless of the domain 
name of the diagnostic server. It may be regarded as safe provided that 
the authentication tokens are not predictable and are transmitted in a secure 
manner (see Chapter 7). Again, a back-end mechanism for validating tokens 
will need to be implemented. </p>
</li>

<li>
<p>There are two basic methods:</p>
<p>(a) You can intercept the request containing the form submission, 
and add the disabled parameter.</p>
<p>(b) You can intercept the response containing the form, and 
remove the <span class="InlineCode">disabled=true</span> attribute. </p>
</li>
<li>There is no means by which an application can ensure that a piece of 
logic has been run on the client. Everything that occurs on the client is 
within the control of the user. </li>

</ol>
<a name="c6"></a>
<h2>Chapter 6 – Attacking Authentication</h2>
<ol>
<li>
<p>(a) The credentials are transmitted within the query string 
of the URL. These are at risk of unauthorized disclosure via the browser 
history, the logs of the web server and IDS, or simply by appearing on-screen.
</p>
<p>(b) The credentials are transmitted via an unencrypted HTTP 
connection, making them vulnerable to interception by an attacker who is 
suitably positioned on the network.</p>

<p>(c) The password is an English word consisting of four lower 
case alphabetical characters. The application is not enforcing any effective 
password quality rules. </p>
</li>
<li>
<p>Self-registration functions are very often vulnerable to username enumeration 
because users can choose their own username and the application prevents 
them from registering an existing username.</p>
<p>Applications can avoid self-registration functionality being misused 
in this way through two methods:</p>
<p>(a) The application can generate its own usernames, assigning 
a non-predictable username to each new user when they have supplied the 
required personal information.</p>
<p>(b) The first step of the self-registration process can require 
users to enter their email address. The application then sends the user 
an email containing a one-time URL that they can use to continue the registration 
process. If the supplied email address is already registered, the user is 
notified of this in the email. </p>

</li>
<li>
<p>The rationale for requesting two randomly chosen letters from the user’s 
memorable word, rather than the entire word, is that even if an attacker 
captures all of the credentials supplied by a user in a single login, it 
is unlikely that the attacker will be able to repeat the login using those 
credentials, because a different pair of letters will be requested.</p>
<p>If the application requests all of the required information in a single 
step, then it must select the randomly chosen letters in advance, without 
knowing the claimed identity of the authenticating user. This means that 
an attacker who knows only two letters from a user’s memorable word can 
simply reload the login form repeatedly until those two letters are requested, 
enabling them to log in using the captured credentials.</p>
<p>To avoid this defect, the application must choose a new pair of letters 
following each successful login, and store these in the user’s profile until 
such time as the user successfully logs in again. When the user has identified 
themselves at stage one of the login, the pair of letters is retrieved from 
their profile, and requested from the user. In this way, an attacker who 
has captured the credentials in a single login will typically need to wait 
a very long period until the them items are re-requested by the application.
</p>
</li>
<li>

<p>An attacker attempting to guess valid credentials can easily determine 
whether an individual item is valid or invalid. The application’s behavior 
effectively enables an attacker to break down the brute-force problem into 
a series of individual challenges.</p>
<p>The vulnerability can be corrected by continuing through all steps of 
the login process even if an invalid item is submitted, returning a generic 
“login failed” message after the final stage, regardless of which item caused 
the failure. This massively increases the number of requests required to 
guess a user’s credentials using brute force. </p>
</li>
<li>
<p>The presence of the anti-phishing mechanism enables an attacker to break 
the problem of guessing valid credentials into two stages. An attacker can 
verify whether or not a particular username and date of birth are valid 
by completing step (a) twice with these values. If the same anti-phishing 
image is returned on each occasion, then the guessed credentials are almost 
certainly valid; otherwise, they are not. A scripted attack could quickly 
iterate through a wide range of dates of birth for a targeted username, 
in order to guess the correct value.</p>
<p>Worse still, the mechanism devised is not effective in preventing phishing 
attacks. A cloned web application will receive the username and date of 
birth supplied by the user in step (a), and can submit these directly to 
the original application to retrieve the correct image to present to the 
user in step (b). If users have been told to trust the image to provide 
assurance of the application’s identity, then the mechanism may actually 
be counter-productive and may cause users to log in to a phishing site that 
they would not otherwise trust. </p>
</li>

</ol>
<a name="c7"></a>
<h2>Chapter 7 – Attacking Session Management</h2>
<ol>
<li>
<p>The <span class="InlineCode">sessid</span> cookie contains a Base64-encoded 
string. Decoding the two values you received reveals the following values:
</p>

<p><span class="InlineCode">jim23:1241:1194870863</span></p>
<p><span class="InlineCode">jim23:1241:1194875132</span></p>
<p>The decoded cookie contains three items of data, separated by semicolons. 
On first inspection, the three values may contain a username, numeric user 
identifier, and a changing numeric value. The latter contains 10 digits, 
and looks like a Unix time value. Translating these two values reveals the 
following:</p>
<p><span class="InlineCode">Mon, 12 Nov 2007 12:34:23 UTC</span></p>
<p><span class="InlineCode">Mon, 12 Nov 2007 13:45:32 UTC</span></p>
<p>These represent the times at which each of your sessions was created.</p>

<p>Hence, it appears that the session tokens are comprised of meaningful 
user-specific data and a predictable item. In principle, you could mount 
a brute force attack to guess the tokens issued to other application users.
</p>
</li>
<li>
<p>A 6-character session token allows for a considerably larger range of 
possible values than a 5-character password. It may therefore appear that 
the shorter passwords present the most worthwhile target for an attack.</p>
<p>However, there are important differences between brute force attacks 
targeting passwords and those targeting session tokens. When attempting 
to guess passwords, it is necessary to supply a username and password together, 
thus targeting at most one account with each request, and maybe none at 
all. You may already know some usernames, or be able to enumerate them, 
or you may need to guess usernames and passwords simultaneously. The login 
mechanism may contain multiple stages, or be slow to respond. The login 
mechanism may also enforce account lockout, considerably slowing down your 
attack.</p>
<p>When attempting to guess session tokens, on the other hand, you can often 
target multiple users simultaneously. There may be 20 users logged in, or 
2000, or zero. If a user is not presently logged in, then you cannot target 
them in this way. There is no easy way for an application to enforce any 
kind of “lockout” when a large number of invalid tokens are received. Token 
guessing attacks normally run very quickly – requests containing an invalid 
token usually receive a fast response containing an error message or redirection.</p>
<p>In short, there is no definitive answer to the question, and the most 
worthwhile target will depend upon your purposes and other aspects of the 
application. If many users are logged in and you simply need to compromise 
any user, then targeting sessions may be best. If you wish to compromise 
the single administrative account, which rarely logs in, then a password 
guessing attack will be more effective. </p>

</li>
<li>
<p>(a) Yes. The domain and path both match the scope of the 
cookie.</p>
<p>(b) No. The domain is not the same or a subdomain of the 
domain scope of the cookie.</p>
<p>(c) Yes. The domain is a subdomain of the domain specified 
in the scope, and the path matches the scope.</p>
<p>(d) Yes. The domain and path both match the scope of the 
cookie. Although the protocol is HTTP, the <span class="InlineCode">secure</span> 
flag was not specified, so the cookie is still transmitted.</p>

<p>(e) Yes. The domain matches the scope of the cookie. Because 
the path scope did not include a trailing slash after
<span class="InlineCode">/login</span>, the scope includes not only the 
path <span class="InlineCode">/login/</span> but also any other patch matching 
the <span class="InlineCode">/login</span> prefix.</p>
<p>(f) No. The path does not match the scope of the cookie.</p>
<p>(g) No. The domain is the parent of the domain specified 
in the scope, and so is not included.</p>

<p>(h) No. The domain is not the same or a subdomain of the 
domain scope of the cookie.</p>
<p>Note that the <span class="InlineCode">HttpOnly</span> flag affects whether 
cookies are accessible via client-side JavaScript. It does not determine 
whether they are transmitted via HTTP or HTTPS connections. </p>
</li>
<li>Session hijacking is still possible. If an attacker obtains the tokens 
issued to a user, the attacker can immediately make requests using those 
tokens, and the server will accept the requests. However, if the user issues 
a single further request to the application, then the per-page token submitted 
by the user will be out of sequence, and the entire session will be invalidated. 
Hence, if the user is still interacting with the application, the window 
for exploitation may be very small. If an attacker simply wishes to perform 
a specific action with the user’s privileges, it is likely that they can 
script an attack to perform the desired action within the available window.
</li>
<li>
<p>The logout function is broken.</p>

<p>The script invalidates the session token currently held in the browser, 
meaning that its previous value will not be submitted in any subsequent 
requests. It then initiates a redirection to the application start page. 
Any attempt to access protected functionality will be denied because the 
request will not be made as part of an authenticated session.</p>
<p>However, the client-side application does not communicate to the server 
that a logout action has been performed. The user’s session on the server 
will remain active, and the token previously issued will continue to be 
accepted if issued to the server. This will remain the case indefinitely 
until the session is timed out or otherwise cleaned up. During that interval, 
an attacker who has captured or guessed the token’s value through some means 
can continue to use it to hijack the user’s session. </p>
</li>
</ol>
<a name="c8"></a>
<h2>Chapter 8 – Attacking Access Controls</h2>

<ol>
<li>Choose a range of important application functions that you are authorized 
to access. Walk through each function submitting a modified or absent
<span class="InlineCode">Referer</span> header. If the application rejects 
your requests, it may well be vulnerable. Try making the same requests in 
a user context where these are unauthorized, but restore the original
<span class="InlineCode">Referer</span> header each time. If the requests 
are now accepted, then the application is certainly vulnerable. </li>
<li>
<p>You should attempt the following tests, in order of effectiveness:</p>
<p>(a) Modify the <span class="InlineCode">uid</span> value 
to a different value with the same syntactic form. If your own account details 
are still returned, then the application is probably not vulnerable.</p>

<p>(b) If you are able to register or otherwise access a different 
user account, log in using that account to obtain the other user’s
<span class="InlineCode">uid</span> value. Using your original user context, 
substitute this new <span class="InlineCode">uid</span> in place of your 
own. If sensitive data about the other user is displayed, then the application 
is vulnerable.</p>
<p>(c) Use a script to iterate up and down for a few thousand 
values from your <span class="InlineCode">uid</span>, and determine whether 
any other users’ details are returned.</p>
<p>(d) Use a script to request random
<span class="InlineCode">uid</span> values between 0 and 9999999999 (in 
the present example) and determine whether any other users’ details are 
returned. </p>

</li>
<li>
<p>It is possible to spoof another user’s IP address, although in practice 
this may be extremely difficult. More significantly, different end users 
on the Internet may share the same IP address if they are behind the same 
web proxy or NAT-ting firewall. </p>
<p>One way in which IP-based access controls can be effective in this situation 
is as a defense-in-depth measure to ensure that users attempting to access 
administrative functions are located on the organization’s internal network. 
Those functions should also, of course, be protected by robust authentication 
and session handling mechanisms. </p>
</li>
<li>
<p>There is no horizontal or vertical segregation of access within the application, 
so there is no need for any access controls that discriminate between different 
individual users. </p>

<p>Even though all users are in the same category, the application still 
needs to restrict the actions that any user can perform. A robust solution 
will use the principle of least privilege to ensure that all user roles 
within the application’s architecture have the minimum permissions necessary 
for the application to function. For example, because users only need read 
access to data, the application should access the database using a low privileged 
account with read-only permissions to only the relevant tables. </p>
</li>
<li>The files are Excel spreadsheets. These are static resources which cannot 
enforce any access controls over themselves, in the way that dynamic scripts 
can. It is possible that the application is using other methods, such as 
at the web server layer, to protect access to the resources, but this is 
not typically the case. You should quickly check whether the resources can 
be accessed without authentication. </li>
</ol>
<a name="c9"></a>
<h2>Chapter 9 – Attacking Data Stores</h2>
<ol>
<li>
<p>You can determine the number of columns in two easy ways. First, you 
can <span class="InlineCode">SELECT</span> the type-neutral value
<span class="InlineCode">NULL</span> from each column, increasing the number 
of columns until the application returns data, indicating that the correct 
number of columns were specified, for example:</p>
<p><span class="InlineCode">' UNION SELECT NULL--</span></p>

<p><span class="InlineCode">' UNION SELECT NULL, NULL--</span></p>
<p><span class="InlineCode">' UNION SELECT NULL, NULL, NULL--</span></p>
<p>Note that on Oracle you will need to add <span class="InlineCode">FROM 
DUAL</span> after the final <span class="InlineCode">NULL</span> in each 
case.</p>

<p>Second, you can inject <span class="InlineCode">ORDER BY</span> clauses 
and increment the specified column until an error occurs, indicating that 
an invalid column was requested:</p>
<p><span class="InlineCode">' ORDER BY 1--</span></p>
<p><span class="InlineCode">' ORDER BY 2--</span></p>
<p><span class="InlineCode">' ORDER BY 3--</span> </p>

</li>
<li>
<p>An easy way to confirm the database type is to use database-specific 
string concatenation syntax to construct some benign input within the query 
you control. For example, if the original value of the parameter is
<span class="InlineCode">London</span> you can submit the following items 
in turn:</p>
<p><span class="InlineCode">'||'London</span></p>
<p><span class="InlineCode">'+'London</span></p>

<p>If the first results in the same behavior as the original, the database 
is probably Oracle. If the second results in the same behavior, the database 
is probably MS-SQL. </p>
</li>
<li>
<p>While it may seem counterintuitive, the user registration function is 
probably the safest. Registration functions normally use
<span class="InlineCode">INSERT</span> statements, which are unlikely to 
affect other records if you modify them. A function to update personal records 
is probably using conditional <span class="InlineCode">UPDATE</span> statements. 
If you inject a payload like <span class="InlineCode">' or 1=1--</span> 
you may cause all records in the table to be modified. Similarly, the function 
to unsubscribe is probably using conditional <span class="InlineCode">DELETE</span> 
statements, and could impact on other users if you are not careful.</p>

<p>That said, it is impossible to be completely certain in advance which 
statements are being carried out by any kind of functionality, and you should 
advise the application owner of the risks before you perform the test.
</p>
</li>
<li>An easy way to achieve the same effect without using comment characters 
is with the input <span class="InlineCode">' or 'a'='a</span>. </li>
<li>
<p>You can SQL comment characters to separate keywords and other items in 
your injected payloads, for example:</p>

<p><span class="InlineCode">'/**/UNION/**/SELECT/**/username,password/**/FROM/**/users--</span>
</p>
</li>
<li>
<p>You can use the CHAR command to return a string value from a numeric 
ASCII character code. For example, on Oracle the string
<span class="InlineCode">FOO</span> can be represented as:</p>
<p><span class="InlineCode">CHAR(70)||CHAR(79)||CHAR(79)</span> </p>

</li>
<li><p>This situation arises where user-supplied input is being placed into 
other elements of a query, such as table and column names, rather than the 
query’s parameters. A parameterized query cannot be precompiled with placeholders 
for these items, so a different solution needs to be used, probably based 
on very stringent input validation. </p></li>
<li><p>Because you already have administrative access, it is likely that you 
can retrieve any data you desire using the application itself, meaning that 
a SQL injection attack to retrieve the application’s own data may be redundant. 
However, you can still leverage the attack to access any data relating to 
other applications that is held within the same database, or to escalate 
privileges within the database or the underlying operating system, to compromise 
the database server and extend your attack into the wider internal network.
</p></li>
<li><p>XPath injection can only be used to retrieve data from the targeted 
XML file. Hence, if the application contains no sensitive data this is likely 
to be a low impact issue. Similarly, SQL injection flaws may not enable 
you to extract any sensitive data from the database. However, they can sometimes 
be leveraged to escalate privileges within the database and develop your 
attack in other ways. Depending on the situation, SQL injection may be a 
more significant vulnerability. OS command injection, on the other hand, 
is almost always a high impact vulnerability, because it usually enables 
you to directly compromise the underlying server and use it as the launch 
point for further attacks against internal systems. </p></li>
<li><p>If the function is accessing a database, then submitting the SQL wildcard
<span class="InlineCode">%</span> as the search query is likely to return 
a large number of records. Similarly, if the function is accessing an Active 
Directory, then submitting the wildcard <span class="InlineCode">*</span> 
is likely to return a large number of records. Neither wildcard should have 
the same effect on the other system. </p></li>

</ol>
<a name="c10"></a>
<h2>Chapter 10 – Attacking Back-End Components</h2>
<ol>
<li>
<p>Applications for configuring networking devices often contain 
functionality that cannot be easily implemented using normal web 
scripting APIs, such the ability to reboot the device, cycle log files, 
or reconfigure SNMP. These tasks can often be performed easily using 
one-line operating system commands. Therefore, application developers 
frequently implement the functionality by incorporating the relevant 
user input directly into a shell command string.</p>

</li>
<li>
<p>It appears that the user-supplied input is being incorporated into a 
file path that is used in a filesystem operation. It may be possible to 
provide crafted input to access arbitrary files on the server. 
You should try using <span class="InlineCode">../</span> traversal sequences&nbsp;to 
access different directories. Since <span class="InlineCode">.log</span> is 
being appended to your input, you should try using a NULL byte to 
terminate the filename. Note that the <span class="InlineCode">home</span> 
directory that appears within the error message might be the same 
directory that appears within the URL, giving you a clue about the 
location of items within the web root.</p>

</li>
<li>
<p>The application may be vulnerable to XML external entity (XXE) injection. 
The prerequisites to retrieve the contents of arbitrary files would 
normally be as follows:</p>
<p>(a) The XML interpreter used by the application must support external 
entities.</p>
<p>(b) The application must echo in its response the contents of an XML 
element that appears within the request</p>
</li>
<li>

<p>The variable <span class="InlineCode">param</span> has the value 
<span class="InlineCode">urlparam1,urlparam2,bodyparam,cookieparam</span>.</p>
</li>
<li>
<p>Neither attack is strictly a prerequisite for the other. </p><p>Although HPI 
attacks often involve HPP, they need not do so. For example, an HPI 
attack may inject an entirely new parameter into a back-end request, to 
interfere with the application's processing. This type of attack does 
not depend upon any particular behavior in the application's handling of 
multiple parameters with the same name.</p>
<p>HPP attacks can often be used in situations that do not involve HPI, 
particularly where several layers of processing is performed on user 
input. For example, some exploits against the Internet Explorer XSS 
filter use HPP techniques, but do not inject any parameter into back-end 
requests.</p>

</li>
<li>
<p>There are many alternative representations of the server's loopback 
IP address that could be used to bypass the application's filter. For example: </p>
<ul><li>127.1</li>
<li>127.000.0.1</li>
<li>Any other address in the
127.0.0.0 Class A subnet</li>
<li>Any variations on these in binary 
or
octal representations such as 017700000001.</li></ul>

</li>
<li>
<p>Mail injection attacks against this application function would not 
require the mail server to support mail relaying. Hardcoding the <span class="InlineCode">RCPT TO</span> 
field would not prevent mail injection if other mail headers contain 
user-controller input, since an attacker could inject a second recipient 
using a second <span class="InlineCode">RCPT TO</span> line. The most 
effective defense in this situation is to stricly validate all 
user-supplied inputs to ensure they do not contain any newlines or other 
SMTP metacharacters.</p>
</li>
</ol>

<a name="c11"></a>
<h2>Chapter 11 – Attacking Application Logic</h2>
<ol>
<li>Forced browsing involves circumventing any constraints imposed by in-browser 
navigation on the sequence with which application functions may be accessed. 
You should use forced browsing to test for faulty assumptions in multi-stage 
processes and other areas. These assumptions often lead to access control 
weaknesses which you can exploit using forced browsing. </li>
<li>
<p>If quotation marks are doubled up before the length limit is enforced, 
then you can introduce an odd number of single quotes into your input by 
causing the input to be truncated in between two doubled up quotes (see 
Chapter 9).</p>

<p>If the length limit is applied before the doubling up, then you may still 
be able to exploit any buffer overflow conditions by placing a large number 
of single quotes at the start of your payload, causing this to extend sufficiently 
far to overflow the buffer with crafted data positioned towards the end 
of your payload. </p>
</li>
<li>
<p>Using valid credentials for an account you control, you should repeat 
the login process numerous times, modifying your requests in specific ways:</p>
<ul>
<li>
<p>For each parameter submitted, try submitting an empty 
value, omitting the name/value pair altogether, and submitting the same 
item multiple times with different values.</p>

</li>
<li>
<p>If the process involves multiple stages, try performing 
these stages in a different sequence, skipping individual stages altogether, 
proceeding directly to arbitrary stages, and submitting parameters at 
stages where they are not expected.</p>
</li>
<li>
<p>If the same item of data is submitted more than once, 
probe to determine how each value is processed, and whether data that 
is validated at one stage is trusted later on.</p>
</li>
</ul>

</li>
<li>
<p>The application may well be performing these two checks independently, 
validating the password against one username and the token’s value against 
a different username, and then creating an authenticated session in the 
context of <i>one</i> of the validated usernames. </p>
<p>If an application user who possesses their own physical token manages 
to obtain the password of another user, they may be able to login as that 
user. Conversely, depending on how the logic functions, a user who can read 
the value from another user’s token may be able to login as that user without 
knowing their password. The overall security posture of the solution is 
thus significantly diminished. </p>
</li>
<li>This behavior indicates that the error message functionality is not 
thread safe, and is returning the details of the last error generated by 
any user. You should probe further using two different sessions simultaneously 
to confirm whether this is the case. If so, you should use a script to constantly 
trigger an informative message and log any deviations in its contents for 
interesting information relating to other application users. </li>

</ol>
<a name="c12"></a>
<h2>Chapter 12 – Attacking Users: Cross-Site Scripting</h2>
<ol>
<li>User-supplied input is returned unmodified within the application’s 
response to that input. </li>
<li>

<p>In most cases, XSS flaws within unauthenticated functionality work just 
as effectively against authenticated users – the functionality behaves in 
the same way, resulting in arbitrary JavaScript execution within the context 
of the authenticated user’s session.</p>
<p>Even if a target user is not logged in at the time of the attack, they 
may still be compromised. If the application is vulnerable to session fixation, 
then an attacker can capture their token and wait for them to log in. An 
attacker can inject code into the login page to capture keystrokes, or even 
present a Trojan login form which sends their credentials elsewhere. </p>
</li>
<li>
<p>The answer to the first question is "yes". The behavior of course enables arbitrary 
JavaScript to be injected via a crafted request. The answer to the 
second question is "maybe". Historically, various ways have existed of 
injecting arbitrary HTTP headers into cross-domain requests, to inject a 
malicious cookie. Older versions of Flash and <span class="InlineCode">XMLHttpRequest</span> 
have been vulnerable in this way. Further, many applications designed to 
use a cookie will in fact accept the same named parameter in other 
locations, such as the query string or message body.
</p>
</li>

<li>In isolation, it appears that this behavior could only ever be used 
by a user to attack themselves. However, in conjunction with another suitable 
vulnerability, such as an access control flaw, or cross-site request 
forgery vulnerability, it could be highly significant, 
and could enable an attacker to inject stored JavaScript into the pages 
displayed to other application users. </li>
<li>
<p>If the application displays HTML or text files without any sanitization, 
then JavaScript contained within these will execute within the browser of 
any user who views the attachment. Further, if a JPEG file contains HTML, 
then this will be automatically processed as HTML within some 
browsers. Many web mail applications do not adequately defend against XSS 
in message attachments. </p>
</li>
<li>Because <span class="InlineCode">XMLHttpRequest</span> can be used to 
retrieve the full response from an HTTP request, it can only normally be used to 
make requests to the same domain as the one that is invoking it. 
However, HTML5 has introduced the facility for <span class="InlineCode">XMLHttpRequest</span> 
to make cross-domain requests, and retrieve responses, with the 
permission of the requested domain (see Chapter 13).</li>

<li>
<p>There are countless different attack payloads for XSS exploits. Some 
of the more commonly discussed payloads are:</p>
<ul>
<li>
<p>stealing the session cookie;</p>
</li>
<li>
<p>inducing user actions; </p>

</li>
<li>
<p>injecting Trojan functionality; </p>
</li>
<li>
<p>stealing cached autocomplete data; and</p>
</li>
<li>

<p>loglogging keystrokes.</p>
</li>
</ul>
</li>
<li>
<p>You can “convert” the reflected XSS flaw into a DOM-based one. For example, 
if the vulnerable parameter is called <span class="InlineCode">vuln</span>, 
you can use the following URL to execute an arbitrarily long script:</p>
<p><span class="InlineCode">/script.asp?vuln=&lt;script&gt;eval(location.hash.substr(1))&lt;/script&gt;#alert('long 
script here ......')</span> </p>

</li>
<li>If the POST method is mandatory, you cannot simply construct a crafted 
URL within the application that will execute an attack when a user visits 
it. However, you can create a third-party web page that submits to the vulnerable 
application a form using the POST method and the relevant parameters in 
hidden fields. You can use JavaScript to automatically submit the form when 
a user views your page. </li>
</ol>
<a name="c13"></a>
<h2>Chapter 13 – Attacking Users: Other Techniques</h2>
<ol>

<li>
<p>(a) Arbitrary redirection to lend credibility to a phishing 
attack.</p>
<p>(b) Injection of a cookie header to exploit a session fixation 
flaw.</p>
<p>(c) A response splitting attack to poison the cache of a 
proxy server. </p>
</li>
<li>
<p>An attacker must be able to determine all of the relevant parameters 
to the function in advance – that is, they must not contain any secret or 
unpredictable values that an attacker cannot set without already having 
hijacked a victim’s session. </p>

</li>
<li>
<p>(a) The standard anti-CSRF defense of including an unpredictable 
parameter within requests for JavaScript objects containing sensitive data.</p>
<p>(b) The insertion of invalid or problematic JavaScript at 
the start of a JavaScript response.</p>
<p>(c) The mandatory use of the POST method for retrieval of 
JavaScript objects. </p>
</li>
<li>

<p>(a) Flash will request the file <span class="InlineCode">/crossdomain.xml</span> when a Flash object 
attempts to make a cross-domain request and retrieve the response. Even 
if the object specifies an alternative location from which the 
cross-domain policy should be loaded, Flash will still request <span class="InlineCode">/crossdomain.xml</span> 
to confirm whether this is permitted by the master policy.</p>
<p>(b) Java will not request <span class="InlineCode">/crossdomain.xml</span> 
to check for a cross-domain policy.</p>
<p>(c)HTML5 will not request <span class="InlineCode">/crossdomain.xml</span> 
to check for a cross-domain policy.</p>

<p>(d) Silverlight will request the file <span class="InlineCode">/crossdomain.xml</span> when a 
Silverlight object attempts to make a cross-domain request and retrieve 
the response, provided that the <span class="InlineCode">/clientaccesspolicy.xml</span> 
file, which it requests first, does not exist.</p>
</li>
<li>
<p>Clickjacking attacks involve the attacker's website creating a frame 
containing the vulnerable website. They have nothing to do with whether 
the targeted site itself employs frames.</p>
</li>

<li>
<p>The vulnerability could be exploited using the following steps:</p>
<p>(a) The attacker creates his own account on the application, and 
places a malicious payload into his own display name.</p>
<p>(b) The attacker creates his own site that causes visitors to log in 
to the vulnerable application using the attacker's credentials (via a 
CSRF attack against the login function), and then request the page 
containing the malicious display name.</p>
<p>(c) When a victim is induced to visit the attacker's website, she is 
logged in to the vulnerable application, and the attacker's JavaScript 
executes. This script persists itself within the victim's browser, logs 
out of the application, and presents some content that induces the 
victim to log in using her own credentials. If she does this, then the 
attacker's script can compromise both the victim's credentials and her 
resulting session. From the victim's persepective the attack is seamless 
and appears to involve simply following a link, and then being presented 
with the vulnerable application's own login function.</p>
</li>
<li>

<p>You can add the header </p><p><span class="InlineCode">Origin: attacker.com</span></p><p>to each request, and see 
whether the application responds with the header 
</p><p><span class="InlineCode">Access-Control-Allow-Origin</span></p><p>If so, you can determine from this header 
which external domains (if any) the application permits two-way 
interaction from.</p>
</li>
<li><p>(a) Some applications contain functionality that takes an arbitrary 
name/value in parameters and sets these within a cookie in the response.</p>
<p>(b) Any HTTP header injection or XSS vulnerabilities can be used to 
set arbitrary cookies for the affected domain.</p>
<p>(c) A man-in-the-middle attacker can set cookies for arbitrary 
domains.</p></li>

</ol>
<a name="c14"></a>
<h2>Chapter 14 – Automating Customized Attacks</h2>
<ol>
<li>
<p>(a) HTTP status code</p>

<p>(b) Response length</p>
<p>(c) Contents of response body</p>
<p>(d) Contents of Location header</p>
<p>(e) Setting of any cookies</p>
<p>(f) Occurrence of any time delays </p>
</li>

<li>
<p>There are no definitive answers to this question. The following are examples 
of fuzz strings that are suitable for testing each of the categories of 
vulnerability. There are many other strings that would be equally suitable.</p>
<p>(a)&nbsp;&nbsp; <span class="InlineCode">'</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span class="InlineCode">'; waitfor delay '0:0:30'--</span></p>
<p>(b)&nbsp;&nbsp; <span class="InlineCode">||ping -i 30 127.0.0.1;x||ping 
-n 30 127.0.0.1 &amp;</span> </p>

<p>(c)&nbsp;&nbsp; <span class="InlineCode">../../../../../../../../../../etc/passwd</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span class="InlineCode">..\..\..\..\..\..\..\..\..\..\boot.ini</span></p>
<p>(d)&nbsp;&nbsp; <span class="InlineCode">http://&lt;yourservername&gt;/&nbsp;

</span></p>
</li>
<li>
<p>In many situations, modifying a parameter’s value in some way will result 
in an error, causing the application to stop the rest of its processing 
on that request. The application will not therefore execute various code 
paths in which the other parameters may be processed in unsafe ways.</p>
<p>One effective way to ensure that you achieve a decent level of code coverage 
with your automated fuzzing is to use a benign request as your template, 
and to modify each parameter in turn, leaving the other parameter with their 
initial values. You can then go on to perform manual testing of multiple 
parameters simultaneously, based on the results of the fuzz testing and 
your understanding of the role of each parameter. If time permits, you can 
also go on to perform more elaborate fuzzing, changing multiple parameters 
simultaneously using different permutations of payloads. </p>
</li>
<li>
<p>Often, in addition to the redirection, the application will set a new 
cookie when you submit to valid credentials, assigning you an authenticated 
session that will result in different content when you follow the redirection. 
If this is the case, then you can use the presence of a
<span class="InlineCode">Set-Cookie</span> header as a reliable indicator 
of a hit.</p>

<p>If this is not the case, and the application simply upgrades your existing 
session when you submit valid credentials, then your script will probably 
need to follow the target of the redirection and inspect the contents of 
the resulting page to determine whether you have successfully logged in.
</p>
</li>
<li>If you are lucky, you will be able to devise a regular expression that 
uniquely matches the data preceding the information you need to capture, 
or the data item itself. Otherwise, you will probably need to create a completely 
custom script to parse each application response and identify the interesting 
item. </li>
</ol>
<a name="c15"></a>
<h2>Chapter 15 – Exploiting Information Disclosure</h2>
<ol>
<li>
<p>The application is inserting your input directly into a dynamically constructed 
query. However, it appears to be stripping any whitespace characters from 
your input, as can be seen from the expression <span class="InlineCode">
having1</span> that appears in the error message.</p>
<p>The condition is certainly exploitable. You can use SQL comments instead 
of whitespace to separate items of syntax in your query, for example:</p>

<p><span class="InlineCode">https://wahh-app.com/list.aspx?artist=foo'/**/having/**/1%3d1--</span></p>
<p>which returns the different error message</p>
<p><span class="InlineCode">Server: Msg 8118, Level 16, State 1, Line 1</span></p>
<p><span class="InlineCode">Column 'users.ID' is invalid in the select list 
because it is not contained in an aggregate function and there is no GROUP 
BY clause.</span></p>
<p>This confirms that the condition can be exploited and completes the first 
step in enumerating the structure of the query being performed. </p>

</li>
<li>The error message indicates the usernames that the application is using 
to access the database, the mode of connecting, the absolute file paths 
of the application’s web content, and the line numbers in the scripts where 
the errors were generated. In isolation, each item of information may appear 
inconsequential. However, in conjunction with other vulnerabilities this 
information may assist you in developing a focused attack against the application.
</li>
<li>
<p>This is a system-generated error message produced by
<span class="InlineCode">cgiwrap</span>. It indicates that the script you 
requested cannot be executed on the server because it does not have suitable 
file permissions. This script is therefore probably of little interest to 
you.</p>
<p>The error message contains some information that may be of use, including 
an email address. More significantly, however, it contains various details 
that have been copied from the client request. You should probe the server’s 
handling of crafted input in the relevant request headers to see if the 
error message is vulnerable to XSS. Note that a user can be induced to make 
a request containing arbitrary request headers via a Flash object. </p>
</li>

<li>
<p>You supplied the value <span class="InlineCode">admin</span> in the
<span class="InlineCode">name</span> parameter. The error message indicates 
that the application attempted (and failed) to connect to a database on 
a host named <span class="InlineCode">admin</span>. It appears that the 
application is letting you control the database that it will use to fulfill 
the request.</p>
<p>You should try submitting the IP address or hostname for a server that 
you control, and see if the application connects to you. You should also 
try to guess a range of IP addresses within the internal network, to see 
if you can probe for other databases reachable from the application server.</p>
<p>Given that the supplied hostname has been copied into the error message, 
you should also investigate whether the application is vulnerable to XSS. 
Peripheral content such as error messages is often subject to less rigorous 
input validation and other controls than the primary functionality within 
the application. </p>

</li>
<li>The error message is generated by a script that is attempting to assign 
your string-based input to a numeric variable. It appears that you will 
hit this error any time that you supply data in this parameter that is not 
numeric. There is no indication that your input has caused a database error, 
or even been processed by a database. This parameter is almost certainly 
not vulnerable to SQL injection. </li>
</ol>
<a name="c16"></a>
<h2>Chapter 16 – Attacking Native Compiled Applications</h2>
<ol>

<li>
<p>With stack-based overflows, you can usually get immediate control of 
the saved return address on the stack, and therefore the instruction pointer 
when the current function returns. You can point the instruction pointer 
at an arbitrary address containing your shellcode (usually within the same 
buffer that triggers the overflow).</p>
<p>With heap-based overflows, you can usually set an arbitrary pointer in 
memory to an arbitrary value. Leveraging this modification to take control 
of the flow of execution will normally involve a further step. Further, 
once a heap buffer has been overflowed, your attack may not execute immediately 
but may depend upon unpredictable events that impinge upon the allocation 
of heap memory. </p>
</li>
<li>There is no separate record of the length of a standard C/C++ string. 
The string is considered to continue until the first null byte after the 
start of the string. </li>
<li>
<p>Although it may be relatively easy to probe for and detect a buffer overflow 
vulnerability in a remote web application, developing a working exploit 
for the bug will in general be extremely difficult (though not absolutely 
impossible). </p>

<p>With local access to a vulnerable network device, on the other hand, 
it is possible to attach debugging equipment and fully investigate the nature 
of the vulnerability, and thereby develop a finely crafted attack to exploit 
it reliably. </p>
</li>
<li>
<p>The <span class="InlineCode">%n</span> format specifier has been disabled 
by default in the latest implementations of the <span class="InlineCode">
printf</span> family of functions. Hence, you should always supply a large 
number of <span class="InlineCode">%s</span> specifiers, which will always 
be supported and are very likely to trigger an exception if your input is 
handled in an unsafe way.</p>

<p>Further, using only the <span class="InlineCode">printf</span> family 
of specifiers will not detect vulnerable calls to other formatting functions, 
such as <span class="InlineCode">FormatMessage</span>. </p>
</li>
<li>
<p>You have probably identified a heap overflow vulnerability. Every overlong 
request you are submitting is probably causing corruption of the heap control 
structures. However, heap corruption normally only results in an exception 
when a relevant heap operation takes place, and the timing of this operation 
may depend on other events that are unrelated to the requests you are submitting.</p>
<p>Note that in some rare situations, the same behavior may occur for different 
reasons – for example, because of load balancing or deferred processing 
of your input. </p>

</li>
</ol>
<a name="c17"></a>
<h2>Chapter 17 – Attacking Application Architecture</h2>
<ol>
<li>You can almost certainly exploit the vulnerability to retrieve application 
data held within the database. The application itself must possess the necessary 
credentials and privileges required to access its own data. You can examine 
the server-side application’s scripts and configuration files to discover 
how it access the application. An obvious way to exploit the vulnerability 
you have found would be to create some new scripts within the web root that 
enable you to perform arbitrary queries and retrieve the results using your 
browser. </li>

<li>Even if you fully compromise the entire database server, this may not 
necessarily provide a means of compromising the application server. In a 
typical case, the application server accesses the database server solely 
as a database client, and the database server may not be trusted in any 
other way by the application server.<p>Nevertheless, it is probably possible 
to modify the content returned to users, since some of this will be generated 
using data contained within the database. For example, even if the application 
contains no stored XSS vulnerabilities that can be triggered within the 
application itself, you may be able to inject arbitrary scripts into the 
application’s responses by modifying data directly within the database. 
If this enables you to attack an administrative user then you may quickly 
be able to compromise the entire application. </p>
</li>
<li>The PHP language contains a number of powerful functions, which can 
launch operating system commands and access the file system. If you are 
able to modify the files used by another application, then you can probably 
compromise that application. However, the possibility of achieving this 
depends greatly on the configuration of the PHP environment, and the existence 
of any controls over your actions implemented lower down the technology 
stack. </li>
<li>Locating all application components on the same server normally prevents 
effective segregation between those components, meaning that a compromise 
of one part of the application’s architecture can quickly lead to the compromise 
of others. For example, a file disclosure vulnerability within the web application 
may enable you to retrieve files containing sensitive data from the database. 
Similarly, a SQL injection vulnerability may enable you use database functions 
to write arbitrary files on the server file system, creating scripts within 
the web root that you can access from your browser, and thereby directly 
compromise the application tier. </li>
<li>You can perform Internet searches on key URLs and parameter names to 
locate other applications employing items with the same names. If these 
applications appear to contain a large overlap of shared functionality, 
you can investigate where they are physically hosted to gain additional 
evidence. </li>
</ol>

<a name="c18"></a>
<h2>Chapter 18 – Attacking the Application Server</h2>
<ol>
<li>
<p>A web server will display a directory listing if you request a URL for 
a directory and:</p>
<p>(a) the web server cannot find a default document such as
<span class="InlineCode">index.html</span>;</p>

<p>(b) directory listings are enabled;</p>
<p>(c) you have the required permissions to access the directory.
</p>
</li>
<li>
<p>WebDAV methods allow web-based authoring of web content.</p>
<p>These methods may be dangerous if they are not subjected to strict access 
control. Further, because of the complex functionality involved, they have 
historically been a source of vulnerabilities within web servers – for example, 
as an attack vector for exploiting operating system vulnerabilities via 
the IIS server. </p>
</li>

<li>
<p>If the proxy allows connection back out to the Internet, you could use 
it to attack third party web applications on the Internet, with your requests 
appearing to originate from the misconfigured web server.</p>
<p>Even if requests to the Internet are blocked, you may be able to leverage 
the proxy to access web servers within the organization that are not directly 
accessible, or to reach other web-based services on the server itself.
</p>
</li>
<li>
<p>The PL/SQL Exclusion List is a pattern-matching blacklist designed to 
prevent the PL/SQL gateway from being used to access certain powerful database 
packages.</p>
<p>Various bypasses have been discovered to the PL/SQL Exclusion List filter. 
These essentially arise because the filter employs very simple expressions, 
while the back-end database follows much more complex rules to interpret 
the significance of the input. Numerous ways have been discovered of crafting 
input that does not match the blacklist patterns but nevertheless succeeds 
in executing the powerful packages within the database. </p>

</li>
<li>It is possible that using HTTPS for communication may conceal your attacks 
from some network-layer intrusion detection systems. Using HTTP, however, 
will typically enable your automated attacks to execute much faster. The 
application may contain different content or behave differently when accessed 
via the different protocols, so in general you should be prepared to test 
using both. </li>
</ol>
	
<a name="c19"></a>
<h2>Chapter 19 – Finding Vulnerabilities in Source Code</h2>
<ol>

<li>
<p>(a) Cross-site scripting</p>
<p>(b) SQL injection</p>
<p>(c) Path traversal</p>
<p>(d) Arbitrary redirection</p>
<p>(e) OS command injection</p>

<p>(f) Backdoor passwords</p>
<p>(g) Some native software bugs </p>
</li>
<li>PHP uses a range of different built-in arrays to store user-submitted 
data. If <span class="InlineCode">register_globals</span> is enabled, then 
PHP creates a global variable for every request parameter, and applications 
may access a parameter simply by referencing a variable with the same name 
– there is no syntactic indication that this variable represents user input 
as opposed to any other variable defined elsewhere. </li>
<li>
<p>Method 1 is more secure.</p>

<p>Although method 1 constructs a SQL query dynamically from user input, 
it doubles up all single quotation marks that appear within that input, 
and all user-supplied parameters are treated as string data. Although this 
is not the best practice way to handle SQL queries safely, there does not 
appear to be any opportunity for SQL injection in the present case.</p>
<p>Method 2 uses a parameterized query, which is the preferred way to incorporate 
user-supplied data into SQL statements in a safe way. However, only two 
of the three items of user input are properly parameterized. One of the 
items is erroneously placed directly into the string that specifies the 
query structure, and so the application is fully vulnerable to SQL injection.
</p>
</li>
<li>
<p>The application may be vulnerable to reflected XSS, because it appears 
that an on-screen welcome message is being constructed directly from a request 
parameter.</p>
<p>It is not possible to confirm conclusively whether the application is 
vulnerable from this code snippet alone. To do this, you would need to investigate:</p>
<p>(a) whether any input validation is performed on the
<span class="InlineCode">name</span> parameter elsewhere; and </p>

<p>(b) whether any output validation is performed on
<span class="InlineCode">m_welcomeMessage</span> before it is copied into 
the application’s response. </p>
</li>
<li>
<p>Yes. With knowledge of the token creation algorithm used, it is possible 
to extrapolate forwards and backwards to identify all tokens created by 
the application, on the basis of a single sampled token.</p>
<p>The Java API <span class="InlineCode">java.util.Random</span> implements 
a linear congruential generator that generates pseudo-random numbers according 
to a fully predictable algorithm. Knowing the state of the generator at 
any iteration, it is possible derive the sequence of numbers that it will 
generate next, and (with a little number theory) derive the sequence that 
it generated previously.</p>

<p>However, the <span class="InlineCode">java.util.Random</span> generator 
maintains 48 bits of state, and the <span class="InlineCode">nextInt</span> 
method only returns 32 bits of that state. Capturing a single output from 
the <span class="InlineCode">nextInt</span> method is not sufficient to 
determine the state of the generator, or to predict its sequence of outputs.</p>
<p>In the present case, this difficulty can be easily circumvented because 
the algorithm used by the application makes two successive calls to
<span class="InlineCode">nextInt</span>. Each session token created contains 
32 bits of state from one iteration of the generator, and 32 bits of state 
from the next iteration. Given this information, it is straightforward to 
perform a local brute force exercise to discover the missing 16 bits of 
state at the first iteration (by trying each possible permutation of the 
missing 16 bits, and testing whether the generator outputs the 32 bits captured 
from the second iteration). Once the missing 16 bits have been confirmed, 
the full state of the generator is known, and you can proceed to derive 
subsequent and earlier outputs in the standard way.</p>

<p>Ironically, the developers’ decision to make two calls to
<span class="InlineCode">nextInt</span> and combine the results renders 
the token creation algorithm more vulnerable than it would otherwise be.</p>
<p>See the following paper by Chris Anley for more details of this type 
of attack:</p>
<p><a href="https://web.archive.org/web/20151027041737/http://www.ngssoftware.com/research/papers/Randomness.pdf">http://www.ngssoftware.com/research/papers/Randomness.pdf</a>
</p>
</li>
</ol>

</div>
<div id="BottomBanner">
<p>Copyright © 2011 Dafydd Stuttard and Marcus Pinto. All rights reserved.</p>
</div>




<!--
     FILE ARCHIVED ON 04:17:37 Oct 27, 2015 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 23:47:45 Aug 03, 2019.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  LoadShardBlock: 64.577 (3)
  esindex: 0.015
  captures_list: 124.197
  CDXLines.iter: 20.11 (3)
  PetaboxLoader3.datanode: 97.361 (4)
  exclusion.robots: 0.356
  exclusion.robots.policy: 0.344
  RedisCDXSource: 30.488
  PetaboxLoader3.resolve: 42.469
  load_resource: 97.532
--><style></style></body></html>